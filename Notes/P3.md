因为后续我想在bustub的基础上做一些自己的改动, 所以从P3开始, 作为dbms的初学者, 我整体阅读一遍bustub的源码.

bustub的开机处在`/tools/shell/shell.cpp`中, 可以在这里查看:

> 创建实例 `auto bustub = std::make_unique<bustub::BusTubInstance>("test.bustub");`

后面可以再回来仔细地看一下**bustub::BusTubInstance**中有哪些成员, 大抵能够代表db有哪些组件(有一部分没有, 因为是学习用项目的原因)

> 生成 *__mock_txx* 表 `bustub->GenerateMockTable();`

> 生成*test_xxx*表 `bustub->GenerateTestTable();`

**注意**: *we don't support create / drop table and insert for now*

主体部分是两个循环: 

```c++
// 持续运行, 直到用户退出
while(true) {
  ...
  // 读取用户输入SQL语句
  while(true) {
    ...
    // linenoise库
    char *query_c_str = linenoise(line_prompt.c_str());
    ...
  }
  ...
  // 执行SQL命令
  bustub->ExecuteSql(query, writer);
  ...
}
```

对于处理用户的输入, 可以使用[linenoise开源库](https://github.com/antirez/linenoise)来读取, 也可以选择开启TTY使用标准输入读取(`std::getline`)

**重点是执行SQL语句**, 以SQL语句`SELECT * FROM __mock_table_1;`为例, 看看如何执行的.

### Binder

虽然感觉没啥作用, 也不需要写什么, 不过就**SELECT**语句而言, 还是看一下是如何在**catalog**中将`*`展开的

```c++
#0 binder.BindStatement(stmt);
 #1 BindStatement(...); // 进一步解包
    #2 BindSelect(...);
      #3 BindFrom(pg_stmt->fromClause); // sql: FROM "relname"
        #4 BindTableRef(node);
          #5 BindRangeVar(...);
            #6 BindBaseTableRef(relname,...);
              #7 catalog_.GetTable(table_name);   // 查表
              #7 table_names_.find(table_name);   // 查表
              #7 tables_.find(table_oid->second); // 查表
          #5 BindJoin(...);
          #5 BindRangeSubselect(...);
      #3 BindSelectList(pg_stmt->targetList); // sql: SELECT n1, n2, ...
         #4 for node in list: 
           #5 BindExpression(node);
             #6 BindStar(node); // SELECT *
         #4 GetAllColumns(*scope_); // SELECT *
      #3 BindWhere(pg_stmt->whereClause); // sql: WHERE...
      #3 BindGroupBy(pg_stmt->groupClause); // sql: GROUP BY...
      ...
```

此外, 要查看`statement`中的内容, 有一个好的方式是检查`HandleExplainStatement()`中, 对每个部分调用的`ToString()`函数

在`BindStatement(stmt)`中还能查看对其他语句的解析.

### Planner

### data struct

P3涉及到的数据结构繁杂而庞大, 一言两语我并不能讲清楚, 更多地需要去阅读源码, 我仅记录下一些花费时间比较久才摸索清楚的数据结构.

一个宏观的视角:

```
Executor
   |
   |--------Context
   |           |
   |           |-------Catalog
   |           |          |
   |           |          |-------TableInfo
   |           |          |          |
   |           |          |          |--------Schema................................+
   |           |          |          |          |                                   |
   |           |          |          |          |-----size                          |
   |           |          |          |          |-----Column1 {name, type, size}    |
   |           |          |          |          |-----Column2 {name, type, size}    |
   |           |          |          |          |-----...                           |
   |           |          |          |                                              |
   |           |          |          |--------TableHeap                             |
   |           |          |          |            |                                 |
   |           |          |          |            |------lock                       |
   |           |          |          |            |------TablePage1                 |
   |           |          |          |            |------TablePage2                 |
   |           |          |          |            |          |                      ↓
   |           |          |          |            |          |-------Tuple1 {RID, data}
   |           |          |          |            |          |-------Tuple2 {RID, data}
   |           |          |          |            |          |-------...            ↑
   |           |          |          |            |------...                        |
   |           |          |          |                                              |
   |           |          |          |--------table_id                              |
   |           |          |          |--------table_name                            |
   |           |          |                                                         |
   |           |          |-------IndexInfo                                         |
   |           |          |          |                                              |
   |           |          |          |-------name                                   |
   |           |          |          |-------type                                   |
   |           |          |          |-------index_oid                              |
   |           |          |          |-------Schema(key_schema).....................+
   |           |          |          |-------Index                                  |
   |           |          |          |         |                                    |
   |           |          |          |         |----KeyComparator                   |
   |           |          |          |         |----BPlusTree(...else)              |
   |           |          |          |         |----IndexMetadata                   |
   |           |          |          |         |         |                          |
   |           |          |          |         |         |---------Schema(key_schema)
   |           |          |          |         |         |---------key_attrs_
   |           |          |          |         |         |---------...
   |           |
   |           |-------BPM
   |           |        |...
   |
   |---------PlanNode
   |            |
   |            |--------Schema(output_schema)
   |            |--------Child_Node
   |            |--------Expression
   |            |             |
   |            |             |------Column(ret_type)
   |            |             |------Child_expr

  



Executor--+--Context--+--Catalog--+--Table
          +           +           +--Index
          +           +--bpm      
          +           +--...
          +
          +--PlanNode-+
```


### Aggregation

草, 怎么突然忘了这些个操作是干啥的.

```sql
create table t1(v1 int, v2 int);
insert into t1 values (1, 10), (2, 10), (3, 20), (5, 10), (7, 20);
select * from t1;
+-------+-------+
| t1.v1 | t1.v2 |
+-------+-------+
| 1     | 10    |
| 2     | 10    |
| 3     | 20    |
| 5     | 10    |
| 7     | 20    |
+-------+-------+
```

***group by, min()***

```sql
select v2, min(v1) as min_v1 from t1 group by v2;
+-------+--------+
| t1.v2 | min_v1 |
+-------+--------+
| 20    | 3      |  # v2 = 20,  min_v1 = min{3, 7}
| 10    | 1      |  # v2 = 10,  min_v1 = min{1, 2, 5}
+-------+--------+
```

***count, min()***

```sql
select v2, count(v1) as cnt_v1, min(v1) as min_v1 from t1 group by v2;
+-------+--------+--------+
| t1.v2 | cnt_v1 | min_v1 |
+-------+--------+--------+
| 20    | 2      | 3      | # v2 = 20, cnt_v1 = count{3,7},  min_v1 = ~
| 10    | 3      | 1      | # v2 = 10, cnt_v1 = count{1,2,5},min_v1 = ~
+-------+--------+--------+
```

### Join

$ \pi_{*} (\sigma_{colA = colE} (__mock_table_1 \times __mock_table_3)) $


w $\pi_{*} (\sigma_{colA=colE})$