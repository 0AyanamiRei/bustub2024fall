因为后续我想在bustub的基础上做一些自己的改动, 所以从P3开始, 作为dbms的初学者, 我整体阅读一遍bustub的源码.

bustub的开机处在`/tools/shell/shell.cpp`中, 可以在这里查看:

> 创建实例 `auto bustub = std::make_unique<bustub::BusTubInstance>("test.bustub");`

后面可以再回来仔细地看一下**bustub::BusTubInstance**中有哪些成员, 大抵能够代表db有哪些组件(有一部分没有, 因为是学习用项目的原因)

> 生成 *__mock_txx* 表 `bustub->GenerateMockTable();`

> 生成*test_xxx*表 `bustub->GenerateTestTable();`

**注意**: *we don't support create / drop table and insert for now*

主体部分是两个循环: 

```c++
// 持续运行, 直到用户退出
while(true) {
  ...
  // 读取用户输入SQL语句
  while(true) {
    ...
    // linenoise库
    char *query_c_str = linenoise(line_prompt.c_str());
    ...
  }
  ...
  // 执行SQL命令
  bustub->ExecuteSql(query, writer);
  ...
}
```

对于处理用户的输入, 可以使用[linenoise开源库](https://github.com/antirez/linenoise)来读取, 也可以选择开启TTY使用标准输入读取(`std::getline`)

**重点是执行SQL语句**, 以SQL语句`SELECT * FROM __mock_table_1;`为例, 看看如何执行的.

### Binder

虽然感觉没啥作用, 也不需要写什么, 不过就**SELECT**语句而言, 还是看一下是如何在**catalog**中将`*`展开的

```c++
#0 binder.BindStatement(stmt);
 #1 BindStatement(...); // 进一步解包
    #2 BindSelect(...);
      #3 BindFrom(pg_stmt->fromClause); // sql: FROM "relname"
        #4 BindTableRef(node);
          #5 BindRangeVar(...);
            #6 BindBaseTableRef(relname,...);
              #7 catalog_.GetTable(table_name);   // 查表
              #7 table_names_.find(table_name);   // 查表
              #7 tables_.find(table_oid->second); // 查表
          #5 BindJoin(...);
          #5 BindRangeSubselect(...);
      #3 BindSelectList(pg_stmt->targetList); // sql: SELECT n1, n2, ...
         #4 for node in list: 
           #5 BindExpression(node);
             #6 BindStar(node); // SELECT *
         #4 GetAllColumns(*scope_); // SELECT *
      #3 BindWhere(pg_stmt->whereClause); // sql: WHERE...
      #3 BindGroupBy(pg_stmt->groupClause); // sql: GROUP BY...
      ...
```

此外, 要查看`statement`中的内容, 有一个好的方式是检查`HandleExplainStatement()`中, 对每个部分调用的`ToString()`函数

在`BindStatement(stmt)`中还能查看对其他语句的解析.

### Planner

