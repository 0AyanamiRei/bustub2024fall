# BOOK 15.7

## 执行的不同方式

现在，我们要考虑的是如何对包含多个操作的表达式进行求值: The result of each evaluation is **materialized** in a temporary relation for subsequent use.

**pipelining的优点**

1. 避免中间文件创建+读写的开销
2. 降低延迟

**实现pipeline**

两种类型的pipeline:

1. demand-driven pipeline
2. producer-driven pipeline

对于**需求驱动流水线**, 每个操作都可以抽象为一个**迭代器iterator**, 提供三个函数: `open()`, `next()`, `close()`, 一旦需要某个操作的时候, 能看到的过程就是`open->next->next->next...->next->close`

对于**生产者驱动流水线**, 可以将上下层操作视为生产者消费者, 中间开了一个缓冲区.

我想了一下, 生产者驱动的流水线可以看成是需求驱动流水线和*materialized evaluation*(非流水线执行)的折中, 一开始没有采取流水线, 导致很多的临时文件, 有了更多的读写, 使用了需求驱动的流水线后, 将操作打包在一起, 减小了临时存储的文件. 而生产者驱动的流水线中间开的缓冲区其实就可以视为是小小的临时存储的文件.

二者的差异, 节选了一部分书上的: 

1. 使用生产者驱动管道可以被视为从下方向操作树推送数据，而使用需求驱动管道可以被视为从顶部向操作树拉取数据;
2. 在生产者驱动管道中，元组是积极生成的，而在需求驱动管道中，元组是按需延迟生成的;
3. 生产者驱动管道已经被发现比需求驱动管道在现代CPU上更高效，因为它减少了函数调用的次数

## Query plan

**查询计划Query plans**被定义为在流水线中标记**edges**

我看不懂,但是我大受震撼

# LEC

## zone maps

优化scan的一个技术**zone maps**, 提到一个感兴趣的系统, 在顶层使用区域映射, 在区域内使用索引, 我想的是, 类似B+的内部节点, 这里可以做成层级区域映射+区域内部使用索引, 但是我感觉很明显的一个缺点是, 如果要长久维护, 那么更新数据的成本变高了, 如果不用长久维护, 临时创建然后使用后丢弃又有一点昂贵, 不值得.

## multi-index scan

slides上的例子, 提到了建立的两个索引, 我们应该选择更具有**选择性**的来使用, 课上解释了为什么使用更具选择性的索引更高效, 同时说明了一下最坏的例子, 即两个索引完全不相关;

**什么是选择性**, 我想选择性越强的, 筛选出来的索引集合的数量更小吧, 更容易快速定位;

**为什么选择更具选择性的索引更高效**, 假设A,B谓词, 前者检索得到100w个索引, 后者得到1000w个索引, 但是二者交集只有几条, 先使用索引数量少的集合, 再在其中进一步筛选

## Scheduler

如果您使用显示调度器, 通常情况下, 它会很好地与批处理模式尤其是向量化模型协同工作, 这一部分讲的很有意思, 后面会回来回顾

## midterm review

视频最后几分钟介绍了他们期中考试涵盖的内容, 做完P2后回顾一下