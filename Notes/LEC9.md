# BOOK

可以像对待其他数据库结构一样对待对索引结构的访问，并应用前面讨论过的并发控制技术。但是，由于索引的访问频率很高，因此它们会成为极大的锁争用点，导致并发程度很低。幸运的是，我们不必像对待其他数据库结构那样对待索引；为了最大限度地提高并发性，我们应该以非两阶段的方式尽早释放索引锁。事实上，只要索引查找返回的是正确的图元集，那么事务对索引执行两次查找并发现索引结构在这两次查找之间发生了变化是完全可以接受的。从形式上讲，只要能保证索引的准确性，对索引进行不可序列化的并发访问是可以接受的；接下来我们将正式阐述这一概念。

索引操作的**可序列化操作Operation serializability**定义如下:  如果索引操作的序列化顺序与并发执行中每个索引操作看到的结果以及索引的最终状态一致，则称索引操作的并发执行是可序列化的。操作所看到的结果一致，并且与所有操作执行完毕后索引的最终状态一致，则称该索引操作的并发执行是可序列化的。的最终状态保持一致。索引并发控制技术必须 确保索引操作的任何并发执行都是可序列化的。

我们概述了两种管理 B+ 树并发访问的技术，以及一种防止**phantom phenomenon**的索引并发控制技术。在线书目注释参考了 B+ 树的其他技术以及其他索引结构的技术。我们介绍的 B+ 树并发控制技术基于锁定，但既没有使用两阶段锁定，也没有使用树协议。查找、插入和删除的算法与第 14 章中使用的算法相同，只是稍作修改。

***1. crabbing protocol***

1. 在搜索键值时，Crabbing协议首先以共享模式锁定根节点。在获得子节点的锁后，它会释放父节点的锁。重复这一过程，直到到达叶子节点。

2. 在插入或删除键值时，Crabbing协议会采取以下措施：
  - 它遵循与搜索相同的协议，直到到达所需的叶子节点。在此之前，它只获取（和释放）共享锁。
  - 它以独占模式锁定叶节点，并插入或删除键值。
  - 如果需要拆分节点或将其与同级节点合并，或在同级节点之间重新分配键值，Crabbing协议会以独占模式锁定节点的父节点。执行这些操作后，它会释放节点和同级节点上的锁。

如果父节点需要拆分、聚合或重新分配键值，协议会保留父节点上的锁，并以同样的方式进一步拆分、聚合或重新分配。否则，协议将释放对父节点的锁定。

这个协议的名字来源于螃蟹前进的方式，即交替移动一侧的腿，然后移动另一侧的腿。在该协议中，当操作在树中向下和向上（在分裂、合并或重新分配的情况下）进行时，锁定的进程也以类似的螃蟹式方式进行。一旦某个操作释放了对节点的锁，其他操作就可以访问该节点。

在树向下搜索的操作和向上传播的分裂、合并或重新分配之间，可能存在死锁。系统可以通过在释放操作持有的锁后，从根开始重新启动搜索操作，来轻松处理这种死锁。

锁的保持时间较短，而不是以两阶段的方式保持，通常被称为锁存器。数据库内部使用锁来实现共享数据结构的互斥。在上述情况中，锁的保持方式无法确保插入或删除操作期间的互斥，但索引操作的执行结果是可序列化的。

***2. B-link trees***

第二种技术可以实现更高的并发性，甚至可以避免在一个节点上保持锁，而在另一个节点上获取锁；从而避免了死锁，提高了并发性。**B-link trees**要求每个节点（包括内部节点，而不仅仅是叶子节点）都保持一个指向其右侧同级节点的指针。之所以需要这个指针，是因为在节点被拆分时进行的查找可能不仅要查找该节点，还要查找该节点的右边节点。

与 crabbing 协议不同，B-link trees锁定协议每次只对一个内部节点加锁。在请求对子节点（向下遍历时）或父节点（在拆分或合并过程中向上遍历时）加锁之前，该协议会释放当前内部节点上的锁。这样做可能会导致异常情况：例如，在释放节点上的锁和请求父节点上的锁之间，同级节点上的并发插入或删除可能会导致父节点上的拆分或合并，原始父节点被锁定时可能不再是子节点的父节点。该协议可检测并处理此类情况，在确保操作可序列化的同时，避免了操作之间的死锁，并提高了并发性。

幽灵现象（phantom phenomenon），这是一种在谓词读取和插入或更新之间的冲突未被检测到的情况，可能会导致非可序列化的执行。我们在18.4.3节中看到的索引锁定技术通过分两个阶段锁定索引叶节点来防止幽灵现象。有些索引并发控制方案并不锁定整个索引叶节点，而是对单个键值使用键值锁定，允许从同一个叶节点插入或删除其他键值。键值锁定因此提高了并发性

然而，如果简单地使用键值锁定，可能会出现幽灵现象；为了防止幽灵现象，使用了下一个键锁定技术。在这种技术中，每个索引查找不仅必须锁定在范围内找到的键（或者在点查找的情况下的单个键），还必须锁定下一个键值，即刚好大于在范围内的最后一个键值的键值。同样，每次插入不仅必须锁定插入的值，还必须锁定下一个键值。因此，如果一个事务试图插入一个在另一个事务的索引查找范围内的值，那么这两个事务就会在插入的键值旁边的键值上发生冲突。同样，删除也必须锁定被删除值的下一个键值，以确保检测到与其他查询的后续范围查找的冲突。