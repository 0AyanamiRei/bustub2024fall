# Read
https://15445.courses.cs.cmu.edu/fall2024/project4/

> The undo logs are stored within a specific transaction's in-memory workspace, and transactions themselves are stored in an in-memory data structure which we will call the transaction manager. Note that in a production system these logs would be persisted to disk, but will not require that for BusTub.

**undo log**存储在特定的**transaction's in-memory workspace**中，而*transaction*本身则存储在内存数据结构**transaction manager**中. 在生产系统中，这些日志会被持久化到磁盘上，但在BusTub中则不需要.

Class and Code needed:

1. TableHeap
2. Tuple
3. Value
4. Schema
5. TransactionManager
6. Transaction

一个C++的写法推荐: `auto x = opt.has_value() ? operation(*opt) : std::nullopt;`

## TASK1 Timestamps

```
+---------+---------+---+
| read-ts | cmit-ts |...|
+---------+---------+---+
```

### 1.1 Timestamp Allocation

> When a transaction begins, it is assigned a read timestamp that is equal to the commit timestamp of the most recently committed transaction. 

说明我们需要记录或者查询得到一个信息: `most recently commit timestamp`, 即txn表中, 最大的一个`cmit-ts`

> The commit timestamp determines the serialization order of the transactions. Since these commit timestamps are unique, we can also uniquely identify committed transactions by their commit timestamp.

我们用`cmit-ts`来作为一个txn序列化的标识, 所以展示的图中`ts=xx`, 指的应该是提交时间戳, 对于`read-ts`等于t的事务, 意味着该事务执行于ts=t的事务提交后(思考一下我们如何分配`read-ts`的). 所以对于一条版本链, 假设是*N2O*的顺序, 那么从链头开始, 第一个时间戳小于等于t的就是对该事务可见的版本.

### 1.2 Watermark

**watermark**是未提交或者中止的事务中最小的`read-ts`, 如果不存在这样的事务, 则等于最新的`cmit-ts`, 在本次实验需要以$O(logN)$复杂度实现**watermark**的计算, 在`watermark.h`和`watermark.cpp`文件中查看对应的代码.

- *Watermark::AddTxn*
- *Watermark::RemoveTxn*

> There are many ways to do this. The reference solution implements an amortized O(1) algorithm using a hash map, and there is additionally a useful container in the C++ standard library that might make an O(log N) implementation very easy.

现在可以通过`TxnTimestampTest`测试

---

该问题抽象出来就是维护一个`read_ts`的集合, 集合动态插入/删除元素, 以及动态查询集合内`read_ts`的最小值, 设该集合基数为`n`, 要求查询的时间复杂度为O(logn)及其以下.

1. 维护一个有序数组, O(nlogn)插入删除, O(1)查询
2. 堆, 好像不能指定删除元素 不行
3. Set, 可以


## TASK2 Storage Format and Sequential Scan

要开始介绍bustub中的txn了, 

***如何得到指定版本的tuple?***

1. 获取给定时间戳后发生的所有undo_log;
2. 从最新版本的tuple执行这些undo_log (撤销修改);

与**delta storage**类似, 但是这次实验里没有用于持久化undo_log的**delta table**, 而是记录在每个事务本地workspace

下面让我们重新来认识一下一些类和相关代码.

***Tuple***

`table_heap.h`

