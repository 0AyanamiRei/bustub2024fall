# Read
https://15445.courses.cs.cmu.edu/fall2024/project4/

> The undo logs are stored within a specific transaction's in-memory workspace, and transactions themselves are stored in an in-memory data structure which we will call the transaction manager. Note that in a production system these logs would be persisted to disk, but will not require that for BusTub.

**undo log**存储在特定的**transaction's in-memory workspace**中，而*transaction*本身则存储在内存数据结构**transaction manager**中. 在生产系统中，这些日志会被持久化到磁盘上，但在BusTub中则不需要.

Class and Code needed:

1. TableHeap
2. Tuple
3. Value
4. Schema
5. TransactionManager
6. Transaction

一个C++的写法推荐: `auto x = opt.has_value() ? operation(*opt) : std::nullopt;`

## TASK1 Timestamps

```
+---------+---------+---+
| read-ts | cmit-ts |...|
+---------+---------+---+
```

### 1.1 Timestamp Allocation

> When a transaction begins, it is assigned a read timestamp that is equal to the commit timestamp of the most recently committed transaction. 

说明我们需要记录或者查询得到一个信息: `most recently commit timestamp`, 即txn表中, 最大的一个`cmit-ts`

> The commit timestamp determines the serialization order of the transactions. Since these commit timestamps are unique, we can also uniquely identify committed transactions by their commit timestamp.

我们用`cmit-ts`来作为一个txn序列化的标识, 所以展示的图中`ts=xx`, 指的应该是提交时间戳, 对于`read-ts`等于t的事务, 意味着该事务执行于ts=t的事务提交后(思考一下我们如何分配`read-ts`的). 所以对于一条版本链, 假设是*N2O*的顺序, 那么从链头开始, 第一个时间戳小于等于t的就是对该事务可见的版本.

### 1.2 Watermark

**watermark**是未提交或者中止的事务中最小的`read-ts`, 如果不存在这样的事务, 则等于最新的`cmit-ts`, 在本次实验需要以$O(logN)$复杂度实现**watermark**的计算, 在`watermark.h`和`watermark.cpp`文件中查看对应的代码.

- *Watermark::AddTxn*
- *Watermark::RemoveTxn*

> There are many ways to do this. The reference solution implements an amortized O(1) algorithm using a hash map, and there is additionally a useful container in the C++ standard library that might make an O(log N) implementation very easy.

现在可以通过`TxnTimestampTest`测试

---

该问题抽象出来就是维护一个`read_ts`的集合, 集合动态插入/删除元素, 以及动态查询集合内`read_ts`的最小值, 设该集合基数为`n`, 要求查询的时间复杂度为O(logn)及其以下.

1. 维护一个有序数组, O(nlogn)插入删除, O(1)查询
2. 堆, 好像不能指定删除元素 不行
3. Set, 可以


## TASK2 Storage Format and Sequential Scan

要开始介绍bustub中的txn了, 

***如何得到指定版本的tuple?***

1. 获取给定时间戳后发生的所有undo_log;
2. 从最新版本的tuple执行这些undo_log (撤销修改);

与**delta storage**类似, 但是这次实验里没有用于持久化undo_log的**delta table**, 而是记录在每个事务本地workspace

下面让我们重新来认识一下一些类和相关代码.

***Tuple***

`table_heap.h`

### Tuple Reconstruction

这里讨论的是如何利用undo logs来得到指定版本tuple.

这里材料解释数据结构解释的很清晰, 正确的使用undo_log就能还原得到某个版本的tuple, 但是还有一些疑问:

1. 对于给定的Tuple, 一个txn是否最多持有一个版本的undo log?
2. 对于`is_delete = true`的undo_log, 其version chain不应该就此中断么, 为什么还会有延续(可以看到材料中的图ts=3后面还有ts=4)

### 2.2

`CollectUndoLogs(read-ts) -> std::vector<UndoLog>` : 该函数会根据给定事务的读取时间戳返回重构元组所需的所有撤销日志, 这里会出现两个时间戳: 

1. `base_meta.ts_`
2. `txn->GetReadTs()`

根据大小比较的结果返回日志:

- `base_meta.ts_ == read-ts`: 也就是材料的第一个情况, *The tuple in the table heap is the most recent data relative to the read timestamp.* 返回一个空的`std::vector`即可
- `base_meta.ts_ > read-ts`: 表明该tuple被修改过, 需要在version chain中截取足够的undo日志来重构`read-ts`版本下的tuple
- `base_meta.ts_ < read-ts`: ?

> 材料上没有按照这里的时间戳比较来分类, 其说的第二第三种情况需要理解下: 

在这之前, 先看一下如何解读`int64_t`类型的时间戳, BusTub中的时间戳被设计来可以用于区分**已提交事务的时间戳**和**临时事务的时间戳**, 二者的区别可以单从变量的值看出来, 前者属于[0, `TXN_START_ID` -1], 后者大于`TXN_START_ID`, `TXN_START_ID = 1 << 62`, 
