# Read
https://15445.courses.cs.cmu.edu/fall2024/project4/

> The undo logs are stored within a specific transaction's in-memory workspace, and transactions themselves are stored in an in-memory data structure which we will call the transaction manager. Note that in a production system these logs would be persisted to disk, but will not require that for BusTub.

**undo log**存储在特定的**transaction's in-memory workspace**中，而*transaction*本身则存储在内存数据结构**transaction manager**中. 在生产系统中，这些日志会被持久化到磁盘上，但在BusTub中则不需要.

Class and Code needed:

1. TableHeap
2. Tuple
3. Value
4. Schema
5. TransactionManager
6. Transaction

一个C++的写法推荐: `auto x = opt.has_value() ? operation(*opt) : std::nullopt;`

## TASK1 Timestamps

```
+---------+---------+---+
| read-ts | cmit-ts |...|
+---------+---------+---+
```

### 1.1 Timestamp Allocation

> When a transaction begins, it is assigned a read timestamp that is equal to the commit timestamp of the most recently committed transaction. 

说明我们需要记录或者查询得到一个信息: `most recently commit timestamp`, 即txn表中, 最大的一个`cmit-ts`

> The commit timestamp determines the serialization order of the transactions. Since these commit timestamps are unique, we can also uniquely identify committed transactions by their commit timestamp.

我们用`cmit-ts`来作为一个txn序列化的标识, 所以展示的图中`ts=xx`, 指的应该是提交时间戳, 对于`read-ts`等于t的事务, 意味着该事务执行于ts=t的事务提交后(思考一下我们如何分配`read-ts`的). 所以对于一条版本链, 假设是*N2O*的顺序, 那么从链头开始, 第一个时间戳小于等于t的就是对该事务可见的版本.

### 1.2 Watermark

**watermark**是未提交或者中止的事务中最小的`read-ts`, 如果不存在这样的事务, 则等于最新的`cmit-ts`, 在本次实验需要以$O(logN)$复杂度实现**watermark**的计算, 在`watermark.h`和`watermark.cpp`文件中查看对应的代码.

- *Watermark::AddTxn*
- *Watermark::RemoveTxn*

> There are many ways to do this. The reference solution implements an amortized O(1) algorithm using a hash map, and there is additionally a useful container in the C++ standard library that might make an O(log N) implementation very easy.

现在可以通过`TxnTimestampTest`测试

---

该问题抽象出来就是维护一个`read_ts`的集合, 集合动态插入/删除元素, 以及动态查询集合内`read_ts`的最小值, 设该集合基数为`n`, 要求查询的时间复杂度为O(logn)及其以下.

1. 维护一个有序数组, O(nlogn)插入删除, O(1)查询
2. 堆, 好像不能指定删除元素 不行
3. Set, 可以


## TASK2 Storage Format and Sequential Scan

要开始介绍bustub中的txn了, 

***如何得到指定版本的tuple?***

1. 获取给定时间戳后发生的所有undo_log;
2. 从最新版本的tuple执行这些undo_log (撤销修改);

与**delta storage**类似, 但是这次实验里没有用于持久化undo_log的**delta table**, 而是记录在每个事务本地workspace

下面让我们重新来认识一下一些类和相关代码.

***Tuple***

`table_heap.h`

### 接口实现

task2主要需要实现两个接口: `CollectUndoLogs()`和`ReconstructTuple()`, 这里是其的文档说明:

- `ReconstructTuple()`: 利用*table heap*中的tuple+metadata以及一组undo日志, 重建得到指定版本的tuple; 
- `CollectUndoLogs()`: 从*version chain*中截取足够的undo日志, 以便事务重建tuple

这两个接口有明显的依赖关系, `ReconstructTuple()`需要`CollectUndoLogs()`来收集undo日志, 作为参数传入, 因此此处的一些语义决策需要联系二者来看.

先解释BusTub中的时间戳: 

BusTub中的时间戳被设计来可以用于区分**已提交事务的时间戳**和**临时事务的时间戳**, 二者的区别可以单从变量的值可以区分出来, 前者属于[0, `TXN_START_ID` -1], 后者大于`TXN_START_ID`, `TXN_START_ID = 1 << 62`.

***implement***

根据材料, `CollectUndoLogs`需要处理三个cases, 所以代码就按照不同case分别处理的模式去组织了:

1. **txn足够新, 允许直接读取最新的tuple数据** ,`read-ts`和`tuple-ts`都属于[0, `TXN_START_ID` -1], 且`read-ts >= tuple-ts`
2. **txn正在读取自己修改过的tuple**, `read-ts`和`tuple-ts`都属于[`TXN_START_ID`, `LIMIT`), 且`read-ts == tuple-ts`
3. **其余情况均需要到version chain中收集足够的日志来恢复从前版本的tuple**


case1和case2均返回空的vector( 注意, 不是返回`std::nullopt` ), 而case3需要沿着version chain添加undo日志, 在第一个满足`read-ts >= undo_log-ts`的日志处停下( 包含该日志 ), 如果version chain遍历结束都没有找到满足该条件的日志, 此时返回`std::nullopt`;

有了足够的undo日志, 那么我们再来重建tuple到指定版本.

由`txn_scan_test`补充得到的case: 

1. tuple被标记为is_deleted, 且undo_logs为空, 直接返回`std::nullopt`;
2. 最后一个undo_log被标记为is_deleted, 同样返回`std::nullopt`;

其余情况需要根据undo_logs的内容来执行日志恢复tuple到指定版本. 这里的代码就见仁见智了, 感觉自己写的不是很简洁, 我暂时是正向执行的undo_logs, 对于BusTub中的undo来说, 这里是可以倒着执行undo_logs来避免冗余修改的.

### 主动踩坑环节

1. 不可以用`read-ts >= tuple-ts`来同时判断case1和case2!, 已提交事务和临时事务的时间戳范围不同, 基准从`TXN_START_ID`开始.
2. `CollectUndoLogs()`中不需要检查tuple是否标记为`is_deleted`, 最新版本被删除也允许使用undo日志恢复到指定版本.


### Q&A

1. 对于给定的Tuple, 一个txn是否最多持有一个版本的undo log?
2. 对于`is_delete = true`的undo_log, 其version chain不应该就此中断么, 为什么还会有延续(可以看到材料中的图ts=3后面还有ts=4)