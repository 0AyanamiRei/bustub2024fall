# Read
https://15445.courses.cs.cmu.edu/fall2024/project4/

> The undo logs are stored within a specific transaction's in-memory workspace, and transactions themselves are stored in an in-memory data structure which we will call the transaction manager. Note that in a production system these logs would be persisted to disk, but will not require that for BusTub.

**undo log**存储在特定的**transaction's in-memory workspace**中，而*transaction*本身则存储在内存数据结构**transaction manager**中. 在生产系统中，这些日志会被持久化到磁盘上，但在BusTub中则不需要.

Class and Code needed:

1. TableHeap
2. Tuple
3. Value
4. Schema
5. TransactionManager
6. Transaction

一个C++的写法推荐: `auto x = opt.has_value() ? operation(*opt) : std::nullopt;`

## TASK1 Timestamps

```
+---------+---------+---+
| read-ts | cmit-ts |...|
+---------+---------+---+
```

### 1.1 Timestamp Allocation

> When a transaction begins, it is assigned a read timestamp that is equal to the commit timestamp of the most recently committed transaction. 

说明我们需要记录或者查询得到一个信息: `most recently commit timestamp`, 即txn表中, 最大的一个`cmit-ts`

> The commit timestamp determines the serialization order of the transactions. Since these commit timestamps are unique, we can also uniquely identify committed transactions by their commit timestamp.

我们用`cmit-ts`来作为一个txn序列化的标识, 所以展示的图中`ts=xx`, 指的应该是提交时间戳, 对于`read-ts`等于t的事务, 意味着该事务执行于ts=t的事务提交后(思考一下我们如何分配`read-ts`的). 所以对于一条版本链, 假设是*N2O*的顺序, 那么从链头开始, 第一个时间戳小于等于t的就是对该事务可见的版本.

### 1.2 Watermark

**watermark**是未提交或者中止的事务中最小的`read-ts`, 如果不存在这样的事务, 则等于最新的`cmit-ts`, 在本次实验需要以$O(logN)$复杂度实现**watermark**的计算, 在`watermark.h`和`watermark.cpp`文件中查看对应的代码.

- *Watermark::AddTxn*
- *Watermark::RemoveTxn*

> There are many ways to do this. The reference solution implements an amortized O(1) algorithm using a hash map, and there is additionally a useful container in the C++ standard library that might make an O(log N) implementation very easy.

现在可以通过`TxnTimestampTest`测试

---

该问题抽象出来就是维护一个`read_ts`的集合, 集合动态插入/删除元素, 以及动态查询集合内`read_ts`的最小值, 设该集合基数为`n`, 要求查询的时间复杂度为O(logn)及其以下.

1. 维护一个有序数组, O(nlogn)插入删除, O(1)查询
2. 堆, 好像不能指定删除元素 不行
3. Set, 可以


## TASK2 Storage Format and Sequential Scan

要开始介绍bustub中的txn了, 

***如何得到指定版本的tuple?***

1. 获取给定时间戳后发生的所有undo_log;
2. 从最新版本的tuple执行这些undo_log (撤销修改);

与**delta storage**类似, 但是这次实验里没有用于持久化undo_log的**delta table**, 而是记录在每个事务本地workspace

下面让我们重新来认识一下一些类和相关代码.

***Tuple***

`table_heap.h`

### 接口实现

task2主要需要实现两个接口: `CollectUndoLogs()`和`ReconstructTuple()`, 这里是其的文档说明:

- `ReconstructTuple()`: 利用*table heap*中的tuple+metadata以及一组undo日志, 重建得到指定版本的tuple; 
- `CollectUndoLogs()`: 从*version chain*中截取足够的undo日志, 以便事务重建tuple

这两个接口有明显的依赖关系, `ReconstructTuple()`需要`CollectUndoLogs()`来收集undo日志, 作为参数传入, 因此此处的一些语义决策需要联系二者来看.

***timestamps***

先解释BusTub中的时间戳: 

```
为了在不改变时间戳结构（只是 int64_t）的情况下支持第 3 种情况，我们将使用时间戳的高位作为标记来表示 “临时 ”时间戳。在 BusTub 中，如果提交时间戳介于 0 和 TXN_START_ID - 1 之间，那么它就是有效的。 TXN_START_ID 被定义为 64 位整数的第二个最有效位（1 << 62）。

如果时间戳的第二个最有效位被设置为 1 (& 1 << 62)，则表示元组已被事务修改，而该事务尚未提交。我们称这个时间戳为 “临时事务时间戳”，其计算方法是 TXN_START_ID + txn_human_readable_id = temp_txn_id。我们采用这种方法来区分带有提交时间戳的已提交元组和某个特定事务 ID 下的未提交元组。请注意，UndoLogs 绝不应包含临时事务时间戳（我们将在后面的章节中解释）。

我们不使用实际最重要位（1 << 63）的原因是，我们可以继续用 < 和 > 直接比较临时时间戳。设置最显著位会导致时间戳为负值。

BusTub 中的第一个事务 ID 是 TXN_START_ID，ID 是单调递增的。请务必理解，事务 ID 与提交时间戳不同，尽管两者都是单调递增的。由于 TXN_START_ID 是一个很难解释的大数字，我们将在日志记录和调试时通过去掉最高位来生成一个人类可读的 ID。您应该不需要手动计算未提交事务的临时时间戳，您可以使用现有的辅助函数 GetTransactionTempTs 返回该事务的临时时间戳（src/include/concurrency/transaction.h）。

我们将使用符号 txn****（其中 *** 是一个人类可读的 ID）来表示交易 ID。例如，txn42 表示 ID 为 TXN_START_ID + 42 的事务，或可由人工读取的 ID 为 42 的事务。假设当前事务的人工可读 ID 是 3，它扫描了一个带有时间戳 TXN_START_ID + 3 的基础元组。那么，事务就知道它自己是元组的最新修改者。处理情况 3 的这个子情况等同于处理情况 1。想一想，如果它看到了另一个未提交事务的临时事务时间戳，会发生什么情况。
```

BusTub中涉及到时间戳, ID的内容:

- **Transaction类**中的两个时间戳标记`read_ts_`, `commit_ts_`, 事务ID: `txn_id_`, 线程ID: `thread_id_`
- **UndoLog结构体**中的时间戳标记: `ts_`
- **UndoLink结构体**中的两个标记: `prev_txn_`, `prev_log_idx_`
- 与**Tuple**有关的, **RID**中的`page_id_`和`slot_num_`, 用来追踪version chain的, **TupleMeta**中的时间戳`ts_`

关注这些标记和时间戳被更新的时机, 从一个事务的生命周期来看:  从`Begin()`开始获得一个txn的句柄, 通过该句柄用户调用`Commit()`结束该事务, 由`TransactionManager`负责分配时间戳以及事务编号等标记

> txn->txn_id_ = next_txn_id_++;  // next_txn_id_初始化为TXN_START_ID
> txn->read_ts_ = last_commit_ts_;
> txn->commit_ts_ = ++last_commit_ts_;

可见txn的`txn_id`是从1<<62开始递增, `read_ts_`和`commit_ts_`则从0开始递增.

和**Tuple**有关的修改关注两个`table_heap`提供的接口即可: `InsertTuple()`, `UpdateTupleMeta()`, 如果您目前还没有修改insert/delete/update算子, 未使用txn为tuple赋予时间戳标记等( 即传入给`InsertTuple`, `UpdateTupleMeta`的参数中, TupleMeta->ts_以及是0 ), 但是我们可以从`txn_scan_test.cpp`中看到其用法.

---

BusTub中的时间戳被设计来可以用于区分**已提交事务的时间戳**和**临时事务的时间戳**, 二者的区别可以单从变量的值可以区分出来, 前者属于[0, `TXN_START_ID` -1], 后者大于`TXN_START_ID`, `TXN_START_ID = 1 << 62`.

***implement***

根据材料, `CollectUndoLogs`需要处理三个cases, 所以代码就按照不同case分别处理的模式去组织了:

1. **txn足够新, 允许直接读取最新的tuple数据** ,`read-ts`和`tuple-ts`都属于[0, `TXN_START_ID` -1], 且`read-ts >= tuple-ts`
2. **txn正在读取自己修改过的tuple**, `read-ts`和`tuple-ts`都属于[`TXN_START_ID`, `LIMIT`), 且`read-ts == tuple-ts`
3. **其余情况均需要到version chain中收集足够的日志来恢复从前版本的tuple**

case1和case2均返回空的vector( 注意, 不是返回`std::nullopt` ), 而case3需要沿着version chain添加undo日志, 在第一个满足`read-ts >= undo_log-ts`的日志处停下( 包含该日志 ), 如果version chain遍历结束都没有找到满足该条件的日志, 此时返回`std::nullopt`;

有了足够的undo日志, 那么我们再调用`ReconstructTuple()`重建tuple.

由`txn_scan_test`补充得到的case: 

1. tuple被标记为is_deleted, 且undo_logs为空, 直接返回`std::nullopt`;
2. 最后一个undo_log被标记为is_deleted, 同样返回`std::nullopt`;

其余情况需要根据undo_logs的内容来执行日志恢复tuple到指定版本. 这里的代码就见仁见智了, 感觉自己写的不是很简洁, 我暂时是正向执行的undo_logs, 对于BusTub中的undo来说, 这里是可以倒着执行undo_logs来避免冗余修改的.

由`txn_scan_hidden_test`补充得到的case: 也就是P4材料提到的, `Think about what should happen if it sees the temporary transaction timestamp of a different uncommitted transaction.` 这种情况我选择保守的做法, 从version chain收集日志来恢复到已提交的tuple版本.

### 主动踩坑环节

1. 不可以用`read-ts >= tuple-ts`来同时判断case1和case2!, 已提交事务和临时事务的时间戳范围不同, 基准从`TXN_START_ID`开始.
2. `CollectUndoLogs()`中不需要检查tuple是否标记为`is_deleted`, 最新版本被删除也允许使用undo日志恢复到指定版本.


### Q&A

1. 对于给定的Tuple, 一个txn是否最多持有一个版本的undo log?
2. 对于`is_delete = true`的undo_log, 其version chain不应该就此中断么, 为什么还会有延续(可以看到材料中的图ts=3后面还有ts=4)

## TASK3 

### 3.1 Insert Executor

这个算子符号插入的都是新的tuple, 所以不需要更新


### 3.2 Commit

### 3.3 Generate Undo Log

### 3.4

处理write-write冲突:

1. If a tuple is being modified by an uncommitted transaction, no other transactions are allowed to modify it.
2. when a transaction A deletes a tuple and commits, and another transaction B that starts before A deletes the same tuple after transaction A has committed. 

检测到W-W冲突时, txn状态需要被设为`TAINTED`, 同时抛出一个`ExecutionException`

### SQL TEST

```SQl
CREATE TABLE t1(a int, b int, c int);

begin;
INSERT INTO t1 VALUES (2,NULL,NULL), (4,4,1), (7,NULL,NULL);
commit;

begin;
delete from t1 where a = 4 and b = 4 and c =1;
update t1 set a = 6, b = NULL, c = NULL where a = 7;
commit;

begin;
INSERT INTO t1 VALUES (5,3,0);
commit;

begin;
delete from t1 where a = 5 and b = 3 and c = 0;
commit;

begin; -- 12
delete from t1 where a = 6;
\txn -1

begin; -- 14
update t1 set a = 1, b = NULL, c = NULL where a = 2;
\txn -1

\dbgmvcc t1
┌──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐
│ RID = 14 / 0     │ ts = txn 14                              │ (1, <NULL>, <NULL>)                                    │
│ ──────────────── │ ──────────────────────────────────────── │ ────────────────────────────────────────────────────── │
│                  │ ts = 5           │ txn 14 @ [0]          │ (2, _, _)                                              │
└──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘

┌──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐
│ RID = 14 / 1     │ ts = 7                                   │ <DELETED> (<NULL>, <NULL>, <NULL>)                     │  
│ ──────────────── │ ──────────────────────────────────────── │ ────────────────────────────────────────────────────── │
│                  │ ts = 5           │ txn 6 @ [0]           │ (4, 4, 1)                                              │
└──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘

┌──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐
│ RID = 14 / 2     │ ts = txn 12                              │ <DELETED> (<NULL>, <NULL>, <NULL>)                     │  
│ ──────────────── │ ──────────────────────────────────────── │ ────────────────────────────────────────────────────── │
│                  │ ts = 7           │ txn 15 @ [0]          │ (6, _, _)                                              │
│                  │ ts = 5           │ txn 6 @ [1]           │ (7, _, _)                                              │
└──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘

┌──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐
│ RID = 14 / 3     │ ts = 11                                  │ <DELETED> (<NULL>, <NULL>, <NULL>)                     │  
│ ──────────────── │ ──────────────────────────────────────── │ ────────────────────────────────────────────────────── │
│                  │ ts = 9           │ txn 10 @ [0]          │ (5, 3, 0)                                              │
└──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘
```

ts=2删除了指定tuple, 而在ts=3的时候该RID处的tuple又被更新了, 在BusTub Web Shell似乎无法构造出这样的version chain

```
RID=1/1 ts=3  (3, <NULL>, <NULL>)
  txn5@0 ts=2 <del>
  txn3@0 ts=1 (4, 4.000000, true)
```


```SQL
begin;
create table t1(a int, b int);
insert into t1 values(1, 1), (2, 2);
commit;

begin;
update t1 set a = -1 where b = 2;
delete from t1 where b = 1;
\txn -1

begin;
update t1 set a = 1 where b = 2;

```

### GC

BusTub的version storage采取增量存储, 因此gc的时候不能使用协同清理**COOP**, 同时为了降低难度, 没有为gc单独开后台线程, 而是停止所有事务, 手动调用`GarbageCollection()`, 因此实现gc的时候我们不需要考虑并发安全.

另外一个问题就是采取事务级还是元组级, 就目前已有的代码来看, 我自己写的应该是事务级的gc.



GC调试
```SQL
CREATE TABLE table1(a int, b int, c int);
SELECT * FROM table1;


INSERT INTO table1 VALUES (0, 0, 0), (1, 1, 1);
commit;

INSERT INTO table1 VALUES (2, 2, 2), (3, 3, 3);
commit;


UPDATE table1 SET a = a + 10;
commit;

begin;
UPDATE table1 SET a = a + 10 WHERE a < 12;
DELETE FROM table1 WHERE a = 21;
commit;


SELECT * FROM table1;

```

### Q&A

1. update/delete 是否需要从指定版本的tuple进行更新/删除?
2. update/delete 中undo_log应该加入到哪个txn的undo_logs?


## TASK4

***case1*** 重复插入相同主键的tuple